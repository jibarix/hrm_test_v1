<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRM City Logistics Evaluation - With Reasoning Logs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border-radius: 0.5rem;
            display: block;
            margin: 0 auto;
        }
        .canvas-container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1;
            margin: 0 auto;
            position: relative;
        }
        .reasoning-step {
            border-left: 3px solid #3b82f6;
            padding-left: 12px;
            margin-bottom: 8px;
        }
        .reasoning-step.final {
            border-left-color: #10b981;
            background-color: #f0fdf4;
            padding: 8px 12px;
            border-radius: 6px;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto bg-white rounded-xl shadow-lg p-4 sm:p-6">
        <div class="text-center mb-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800">HRM City Logistics Evaluation</h1>
            <p class="text-gray-500 mt-1">üß† Testing trained HRM with step-by-step reasoning visualization</p>
        </div>

        <!-- Model Status -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
            <div class="flex items-center justify-between">
                <div>
                    <h3 class="font-semibold text-blue-800">Model Connection Status</h3>
                    <p class="text-sm text-blue-700" id="model-status">Checking connection to HRM server...</p>
                </div>
                <button id="test-connection-btn" class="btn bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md">
                    Test Connection
                </button>
            </div>
        </div>

        <!-- Evaluation Controls -->
        <div id="eval-controls" class="flex flex-col gap-4 mb-4">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                <div class="flex items-center gap-2">
                    <span class="font-semibold text-gray-700">Vehicle:</span>
                    <div id="difficulty-buttons" class="flex flex-wrap gap-2">
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="easy">üö≤ Bike</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="normal">üöó Car</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="hard">üöê Van</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="expert">üöõ Truck</button>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-semibold text-gray-700">Time:</span>
                    <select id="time-selector" class="bg-white border border-gray-300 rounded-lg px-3 py-2 shadow-md">
                        <option value="6">6:00 AM - Early Morning</option>
                        <option value="8" selected>8:00 AM - Rush Hour</option>
                        <option value="10">10:00 AM - Mid Morning</option>
                        <option value="12">12:00 PM - Lunch Hour</option>
                        <option value="14">2:00 PM - Afternoon</option>
                        <option value="17">5:00 PM - Evening Rush</option>
                        <option value="20">8:00 PM - Evening</option>
                        <option value="23">11:00 PM - Late Night</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="log-reasoning" checked class="rounded">
                    <label for="log-reasoning" class="text-sm font-medium text-gray-700">üß† Log Reasoning Steps</label>
                </div>
            </div>
            <div class="text-center">
                <button id="generate-map-btn" class="btn bg-blue-500 text-white font-bold px-6 py-2 rounded-lg shadow-lg">
                    üó∫Ô∏è Generate New Scenario
                </button>
                <button id="predict-btn" class="btn bg-green-500 text-white font-bold px-6 py-2 rounded-lg shadow-lg ml-2">
                    üß† Get HRM Prediction
                </button>
                <button id="compare-oracle-btn" class="btn bg-purple-500 text-white font-bold px-4 py-2 rounded-lg shadow-lg ml-2">
                    ‚öñÔ∏è Compare vs A* Oracle
                </button>
                <button id="animate-reasoning-btn" class="btn bg-orange-500 text-white font-bold px-4 py-2 rounded-lg shadow-lg ml-2" disabled>
                    üé¨ Animate Reasoning
                </button>
            </div>
        </div>
        
        <p id="status" class="text-center text-gray-600 h-6 mb-4"></p>

        <!-- Reasoning Steps Panel -->
        <div id="reasoning-panel" class="bg-gray-50 rounded-lg p-4 mb-4 hidden">
            <h3 class="text-lg font-semibold text-gray-800 mb-3">üß† HRM Reasoning Process</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <h4 class="font-medium text-gray-700 mb-2">Step-by-Step Analysis</h4>
                    <div id="reasoning-steps" class="max-h-64 overflow-y-auto space-y-2 text-sm">
                        <!-- Reasoning steps will be populated here -->
                    </div>
                </div>
                <div>
                    <h4 class="font-medium text-gray-700 mb-2">Reasoning Summary</h4>
                    <div id="reasoning-summary" class="text-sm space-y-1">
                        <!-- Summary will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Display -->
        <div id="results-panel" class="bg-gray-50 rounded-lg p-4 mb-4 hidden">
            <h3 class="text-lg font-semibold text-gray-800 mb-3 text-center">Evaluation Results</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                <div class="text-center">
                    <div class="font-medium text-blue-600">HRM Prediction</div>
                    <div id="hrm-result" class="text-gray-700"></div>
                </div>
                <div class="text-center">
                    <div class="font-medium text-purple-600">A* Oracle</div>
                    <div id="oracle-result" class="text-gray-700"></div>
                </div>
                <div class="text-center">
                    <div class="font-medium text-green-600">Match Status</div>
                    <div id="match-result" class="text-gray-700"></div>
                </div>
            </div>
        </div>

        <!-- Legend -->
        <div class="bg-gray-50 rounded-lg p-4 mb-4">
            <h3 class="text-lg font-semibold text-gray-800 mb-3 text-center">üèôÔ∏è City Traffic Map Legend</h3>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-2 text-sm">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #4a5568;"></div>
                    <span>Buildings/City Park</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #d1d5db;"></div>
                    <span>Side Streets</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #9ca3af;"></div>
                    <span>Major Avenues</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #a78bfa;"></div>
                    <span>Main Diagonal</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #f59e0b;"></div>
                    <span>Heavy Traffic</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #dc2626;"></div>
                    <span>Road Closure</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #10b981;"></div>
                    <span>Start Point</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #ef4444;"></div>
                    <span>Destination</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #3b82f6;"></div>
                    <span>Predicted Route</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full" style="background-color: #34d399;"></div>
                    <span>Vehicle</span>
                </div>
            </div>
            <div class="mt-3 pt-3 border-t border-gray-200">
                <div class="text-xs text-gray-600 space-y-1">
                    <div><span class="font-medium text-blue-600">üß† HRM Reasoning:</span> Watch step-by-step path planning and refinement</div>
                    <div><span class="font-medium text-orange-600">üé¨ Animation:</span> Visualize how HRM evolves its solution over time</div>
                    <div><span class="font-medium text-green-600">üìä Analysis:</span> Compare intermediate vs final paths</div>
                </div>
            </div>
        </div>

        <!-- Canvas for visualization -->
        <div class="canvas-container bg-gray-800 rounded-lg shadow-inner">
             <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <script>
        // --- CONFIGURATION (same as before) ---
        const MAP_DIMENSIONS = { width: 40, height: 40 };

        const COLORS = {
            OBSTACLE: '#4a5568',
            SMALL_ROAD: '#d1d5db',
            LARGE_ROAD: '#9ca3af',
            TRAFFIC_JAM: '#f59e0b',
            ROAD_CLOSURE: '#dc2626',
            START: '#10b981',
            END: '#ef4444',
            PATH: '#3b82f6',
            VEHICLE: {
                easy: '#34d399',
                normal: '#60a5fa', 
                hard: '#facc15',
                expert: '#f87171',
            }
        };

        const TILE_TYPES = {
            OBSTACLE: 0,
            SMALL_ROAD: 1,
            LARGE_ROAD: 2,
            DIAGONAL: 3,
        };

        const VEHICLE_CONFIG = {
            easy:   { name: 'Bike',   allowed_roads: [TILE_TYPES.SMALL_ROAD, TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            normal: { name: 'Car',    allowed_roads: [TILE_TYPES.SMALL_ROAD, TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            hard:   { name: 'Van',    allowed_roads: [TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            expert: { name: 'Truck',  allowed_roads: [TILE_TYPES.LARGE_ROAD] },
        };

        const HRM_TOKEN_MAP = {
            PAD: 0, OBSTACLE: 1, SMALL_ROAD: 2, LARGE_ROAD: 3, DIAGONAL: 4,
            TRAFFIC_JAM: 5, ROAD_CLOSURE: 6, START: 7, END: 8, PATH: 9
        };
        
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const predictBtn = document.getElementById('predict-btn');
        const generateMapBtn = document.getElementById('generate-map-btn');
        const compareOracleBtn = document.getElementById('compare-oracle-btn');
        const animateReasoningBtn = document.getElementById('animate-reasoning-btn');
        const testConnectionBtn = document.getElementById('test-connection-btn');
        const statusEl = document.getElementById('status');
        const modelStatusEl = document.getElementById('model-status');
        const difficultyButtons = document.getElementById('difficulty-buttons');
        const timeSelector = document.getElementById('time-selector');
        const logReasoningCheckbox = document.getElementById('log-reasoning');
        const reasoningPanel = document.getElementById('reasoning-panel');
        const reasoningSteps = document.getElementById('reasoning-steps');
        const reasoningSummary = document.getElementById('reasoning-summary');
        const resultsPanel = document.getElementById('results-panel');
        const hrmResult = document.getElementById('hrm-result');
        const oracleResult = document.getElementById('oracle-result');
        const matchResult = document.getElementById('match-result');

        // --- Game State ---
        let currentDifficulty = 'easy';
        let currentHour = 8;
        let grid = [];
        let trafficGrid = [];
        let startPos = null;
        let endPos = null;
        let isAnimating = false;
        let tileSize = 1;
        let lastHrmPrediction = null;
        let lastOraclePath = null;
        let lastReasoningSteps = [];

        // --- Map Generation (same functions as before) ---
        function generateMap() {
            grid = Array(MAP_DIMENSIONS.height).fill(null).map(() => Array(MAP_DIMENSIONS.width).fill(TILE_TYPES.OBSTACLE));

            const avenues = [3, 8, 13, 18, 23, 28, 33, 37];
            for (let avenue of avenues) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (avenue < MAP_DIMENSIONS.width) {
                        grid[y][avenue] = TILE_TYPES.LARGE_ROAD;
                        if (avenue + 1 < MAP_DIMENSIONS.width) {
                            grid[y][avenue + 1] = TILE_TYPES.LARGE_ROAD;
                        }
                    }
                }
            }

            const streets = [2, 6, 10, 14, 18, 22, 26, 30, 34, 37];
            for (let street of streets) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (street < MAP_DIMENSIONS.height) {
                        grid[street][x] = TILE_TYPES.LARGE_ROAD;
                    }
                }
            }

            for (let y = 4; y < MAP_DIMENSIONS.height; y += 4) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (grid[y][x] === TILE_TYPES.OBSTACLE) {
                        grid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            for (let x = 5; x < MAP_DIMENSIONS.width; x += 6) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (grid[y][x] === TILE_TYPES.OBSTACLE) {
                        grid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            for (let i = 0; i < MAP_DIMENSIONS.width - 5; i++) {
                const x = i;
                const y = Math.floor((i * MAP_DIMENSIONS.height) / MAP_DIMENSIONS.width);
                if (y < MAP_DIMENSIONS.height && x < MAP_DIMENSIONS.width) {
                    grid[y][x] = TILE_TYPES.DIAGONAL;
                    if (y + 1 < MAP_DIMENSIONS.height) grid[y + 1][x] = TILE_TYPES.DIAGONAL;
                }
            }

            const parkStartX = Math.floor(MAP_DIMENSIONS.width * 0.4);
            const parkEndX = Math.floor(MAP_DIMENSIONS.width * 0.65);
            const parkStartY = Math.floor(MAP_DIMENSIONS.height * 0.15);
            const parkEndY = Math.floor(MAP_DIMENSIONS.height * 0.45);
            
            for (let y = parkStartY; y < parkEndY; y++) {
                for (let x = parkStartX; x < parkEndX; x++) {
                    if (x < MAP_DIMENSIONS.width && y < MAP_DIMENSIONS.height) {
                        grid[y][x] = TILE_TYPES.OBSTACLE;
                    }
                }
            }

            placeStartAndEnd();
            updateTrafficAndDraw();
        }

        function placeStartAndEnd() {
            const roadPositions = [];
            
            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (grid[y][x] !== TILE_TYPES.OBSTACLE) {
                        const edgeDistance = Math.min(x, y, MAP_DIMENSIONS.width - 1 - x, MAP_DIMENSIONS.height - 1 - y);
                        if (edgeDistance >= 2) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
            }

            if (roadPositions.length >= 2) {
                let attempts = 0;
                do {
                    const startIdx = Math.floor(Math.random() * roadPositions.length);
                    startPos = roadPositions[startIdx];
                    
                    const validEndPositions = roadPositions.filter(pos => {
                        const distance = Math.abs(pos.x - startPos.x) + Math.abs(pos.y - startPos.y);
                        return distance >= 15 && distance <= 50;
                    });
                    
                    if (validEndPositions.length > 0) {
                        endPos = validEndPositions[Math.floor(Math.random() * validEndPositions.length)];
                        break;
                    }
                    
                    attempts++;
                } while (attempts < 10);
                
                if (attempts >= 10) {
                    startPos = roadPositions[0];
                    endPos = roadPositions[roadPositions.length - 1];
                }
            } else {
                startPos = { x: 5, y: 5 };
                endPos = { x: MAP_DIMENSIONS.width - 5, y: MAP_DIMENSIONS.height - 5 };
            }
        }

        function addTraffic(baseGrid, hour) {
            let newTrafficGrid = baseGrid.map(row => [...row]);
            
            let trafficIntensity = 0;
            let constructionActive = false;
            
            if (hour >= 7 && hour <= 9) {
                trafficIntensity = 0.4;
            } else if (hour >= 17 && hour <= 19) {
                trafficIntensity = 0.45;
            } else if (hour >= 12 && hour <= 13) {
                trafficIntensity = 0.25;
            } else if (hour >= 2 && hour <= 5) {
                constructionActive = true;
                trafficIntensity = 0.1;
            } else {
                trafficIntensity = 0.1;
            }

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const roadType = baseGrid[y][x];
                    
                    if (roadType === TILE_TYPES.LARGE_ROAD || roadType === TILE_TYPES.DIAGONAL) {
                        if (constructionActive && Math.random() < 0.05) {
                            newTrafficGrid[y][x] = 'ROAD_CLOSURE';
                        } else if (Math.random() < trafficIntensity) {
                            newTrafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    } else if (roadType === TILE_TYPES.SMALL_ROAD) {
                        if (Math.random() < trafficIntensity * 0.3) {
                            newTrafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    }
                }
            }

            return newTrafficGrid;
        }

        function updateTrafficAndDraw() {
            trafficGrid = addTraffic(grid, currentHour);
            drawMap(trafficGrid);
            reasoningPanel.classList.add('hidden');
            resultsPanel.classList.add('hidden');
            animateReasoningBtn.disabled = true;
        }

        function gridToHRMSequence(baseGrid, trafficGrid, startPos, endPos) {
            const sequence = new Array(MAP_DIMENSIONS.width * MAP_DIMENSIONS.height);
            
            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const idx = y * MAP_DIMENSIONS.width + x;
                    
                    if (startPos && startPos.x === x && startPos.y === y) {
                        sequence[idx] = HRM_TOKEN_MAP.START;
                    } else if (endPos && endPos.x === x && endPos.y === y) {
                        sequence[idx] = HRM_TOKEN_MAP.END;
                    } else if (trafficGrid[y][x] === 'TRAFFIC_JAM') {
                        sequence[idx] = HRM_TOKEN_MAP.TRAFFIC_JAM;
                    } else if (trafficGrid[y][x] === 'ROAD_CLOSURE') {
                        sequence[idx] = HRM_TOKEN_MAP.ROAD_CLOSURE;
                    } else {
                        switch (baseGrid[y][x]) {
                            case TILE_TYPES.OBSTACLE: sequence[idx] = HRM_TOKEN_MAP.OBSTACLE; break;
                            case TILE_TYPES.SMALL_ROAD: sequence[idx] = HRM_TOKEN_MAP.SMALL_ROAD; break;
                            case TILE_TYPES.LARGE_ROAD: sequence[idx] = HRM_TOKEN_MAP.LARGE_ROAD; break;
                            case TILE_TYPES.DIAGONAL: sequence[idx] = HRM_TOKEN_MAP.DIAGONAL; break;
                            default: sequence[idx] = HRM_TOKEN_MAP.OBSTACLE;
                        }
                    }
                }
            }
            
            return sequence;
        }

        // --- Enhanced HRM Prediction with Reasoning Logs ---
        async function getHRMPrediction(inputSequence) {
            statusEl.textContent = 'üß† HRM is thinking step-by-step...';
            predictBtn.disabled = true;

            try {
                const response = await fetch('http://127.0.0.1:5000/predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        inputs: inputSequence,
                        log_intermediate: logReasoningCheckbox.checked
                    })
                });

                if (!response.ok) {
                    throw new Error(`Model server error: ${response.statusText}`);
                }

                const result = await response.json();
                
                // Store reasoning steps
                lastReasoningSteps = result.reasoning_steps || [];
                
                // Display reasoning analysis
                if (lastReasoningSteps.length > 0) {
                    displayReasoningSteps(lastReasoningSteps);
                    reasoningPanel.classList.remove('hidden');
                    animateReasoningBtn.disabled = false;
                }
                
                predictBtn.disabled = false;
                
                // Return path coordinates for visualization
                return result.path_coords || [];

            } catch (error) {
                console.error("Error getting prediction:", error);
                statusEl.textContent = "‚ùå Could not connect to HRM server. Is it running?";
                predictBtn.disabled = false;
                return [];
            }
        }

        function displayReasoningSteps(steps) {
            reasoningSteps.innerHTML = '';
            reasoningSummary.innerHTML = '';
            
            // Display each step
            steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = `reasoning-step ${step.halted ? 'final' : ''}`;
                
                const pathLength = step.path_length || 0;
                const stepType = step.halted ? 'üéØ Final' : 'üîç Exploring';
                
                stepDiv.innerHTML = `
                    <div class="font-medium">${stepType} Step ${step.step}</div>
                    <div class="text-gray-600">Path length: ${pathLength} waypoints</div>
                `;
                
                reasoningSteps.appendChild(stepDiv);
            });
            
            // Display summary
            const totalSteps = steps.length;
            const finalStep = steps[steps.length - 1];
            const finalPathLength = finalStep?.path_length || 0;
            
            reasoningSummary.innerHTML = `
                <div><strong>Total reasoning steps:</strong> ${totalSteps}</div>
                <div><strong>Final path length:</strong> ${finalPathLength} waypoints</div>
                <div><strong>Reasoning type:</strong> ${totalSteps > 1 ? 'Multi-step deliberation' : 'Immediate solution'}</div>
                <div class="mt-2 p-2 bg-blue-50 rounded text-blue-700">
                    <strong>Analysis:</strong> ${totalSteps > 1 ? 
                        'HRM used multiple reasoning steps to refine its solution' : 
                        'HRM found a direct solution without additional refinement'}
                </div>
            `;
        }

        // --- Reasoning Animation ---
        async function animateReasoning() {
            if (lastReasoningSteps.length === 0) return;
            
            animateReasoningBtn.disabled = true;
            statusEl.textContent = 'üé¨ Animating HRM reasoning process...';
            
            for (let i = 0; i < lastReasoningSteps.length; i++) {
                const step = lastReasoningSteps[i];
                const path = step.path || [];
                
                // Highlight current step in reasoning panel
                const stepElements = reasoningSteps.children;
                for (let j = 0; j < stepElements.length; j++) {
                    stepElements[j].style.backgroundColor = j === i ? '#dbeafe' : '';
                }
                
                // Draw map with current reasoning step
                drawMap(trafficGrid, path);
                statusEl.textContent = `üß† Step ${step.step}: ${path.length} waypoints${step.halted ? ' (Final)' : ''}`;
                
                // Wait before next step
                await new Promise(resolve => setTimeout(resolve, step.halted ? 2000 : 1500));
            }
            
            // Reset highlighting
            const stepElements = reasoningSteps.children;
            for (let j = 0; j < stepElements.length; j++) {
                stepElements[j].style.backgroundColor = '';
            }
            
            animateReasoningBtn.disabled = false;
            statusEl.textContent = '‚úÖ Reasoning animation complete';
        }

        // --- Rest of the functions (A*, visualization, etc.) remain the same ---
        function solvePathAStar(dynamicGrid, start, end, vehicle) {
            const openSet = [start];
            const cameFrom = {};
            const closedSet = new Set();
            
            const gScore = {};
            const fScore = {};

            const startKey = `${start.x},${start.y}`;
            gScore[startKey] = 0;
            fScore[startKey] = heuristic(start, end);

            while (openSet.length > 0) {
                let current = openSet[0];
                let currentIndex = 0;
                for (let i = 1; i < openSet.length; i++) {
                    const currentF = fScore[`${openSet[i].x},${openSet[i].y}`] || Infinity;
                    const bestF = fScore[`${current.x},${current.y}`] || Infinity;
                    if (currentF < bestF) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }

                if (current.x === end.x && current.y === end.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(currentIndex, 1);
                closedSet.add(`${current.x},${current.y}`);
                
                const neighbors = getNeighbors(current, dynamicGrid, vehicle);
                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    const currentKey = `${current.x},${current.y}`;
                    
                    if (closedSet.has(neighborKey)) continue;
                    
                    const cost = getCost(dynamicGrid[neighbor.y][neighbor.x]);
                    const tentativeGScore = (gScore[currentKey] || 0) + cost;

                    if (tentativeGScore < (gScore[neighborKey] || Infinity)) {
                        cameFrom[neighborKey] = current;
                        gScore[neighborKey] = tentativeGScore;
                        fScore[neighborKey] = gScore[neighborKey] + heuristic(neighbor, end);
                        
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return [];
        }
        
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(node, dynamicGrid, vehicle) {
            const neighbors = [];
            const dirs = [{x:0, y:1}, {x:0, y:-1}, {x:1, y:0}, {x:-1, y:0}];
            for(const dir of dirs) {
                const nextX = node.x + dir.x;
                const nextY = node.y + dir.y;
                if(nextX >= 0 && nextX < MAP_DIMENSIONS.width && nextY >= 0 && nextY < MAP_DIMENSIONS.height) {
                    const tileType = dynamicGrid[nextY][nextX];
                    
                    if (tileType !== TILE_TYPES.OBSTACLE && tileType !== 'ROAD_CLOSURE') {
                        if (vehicle.allowed_roads.includes(tileType) || tileType === 'TRAFFIC_JAM') {
                            neighbors.push({x: nextX, y: nextY});
                        }
                    }
                }
            }
            return neighbors;
        }

        function getCost(tileType) {
            switch(tileType) {
                case 'TRAFFIC_JAM': return 8;
                case 'ROAD_CLOSURE': return Infinity;
                case TILE_TYPES.LARGE_ROAD: return 1;
                case TILE_TYPES.DIAGONAL: return 2;
                case TILE_TYPES.SMALL_ROAD: return 3;
                default: return 1;
            }
        }

        function reconstructPath(cameFrom, current) {
            const totalPath = [current];
            let currentKey = `${current.x},${current.y}`;
            while (cameFrom[currentKey]) {
                current = cameFrom[currentKey];
                currentKey = `${current.x},${current.y}`;
                totalPath.unshift(current);
            }
            return totalPath;
        }

        function calculatePathCost(path, dynamicGrid) {
            let totalCost = 0;
            for (let pos of path) {
                totalCost += getCost(dynamicGrid[pos.y][pos.x]);
            }
            return totalCost;
        }

        function drawMap(dynamicGrid, path = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    let color;
                    switch (dynamicGrid[y][x]) {
                        case TILE_TYPES.OBSTACLE: color = COLORS.OBSTACLE; break;
                        case TILE_TYPES.SMALL_ROAD: color = COLORS.SMALL_ROAD; break;
                        case TILE_TYPES.LARGE_ROAD: color = COLORS.LARGE_ROAD; break;
                        case TILE_TYPES.DIAGONAL: color = '#a78bfa'; break;
                        case 'TRAFFIC_JAM': color = COLORS.TRAFFIC_JAM; break;
                        case 'ROAD_CLOSURE': color = COLORS.ROAD_CLOSURE; break;
                        default: color = COLORS.OBSTACLE;
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            
            if (path.length > 0) {
                ctx.fillStyle = COLORS.PATH;
                path.forEach(p => {
                    ctx.fillRect(p.x * tileSize, p.y * tileSize, tileSize, tileSize);
                });
            }

            if (startPos) {
                ctx.fillStyle = COLORS.START;
                ctx.fillRect(startPos.x * tileSize, startPos.y * tileSize, tileSize, tileSize);
            }
            if (endPos) {
                ctx.fillStyle = COLORS.END;
                ctx.fillRect(endPos.x * tileSize, endPos.y * tileSize, tileSize, tileSize);
            }
        }

        function animateVehicle(path) {
            if (path.length === 0) {
                statusEl.textContent = '‚ö†Ô∏è No route found!';
                return;
            }
            isAnimating = true;
            let step = 0;
            function animationLoop() {
                if (step >= path.length) {
                    isAnimating = false;
                    const cost = calculatePathCost(path, trafficGrid);
                    statusEl.textContent = `üéØ Route complete! ${path.length} steps, cost: ${cost.toFixed(1)}`;
                    return;
                }
                drawMap(trafficGrid, path.slice(0, step + 1));
                const currentPos = path[step];
                ctx.fillStyle = COLORS.VEHICLE[currentDifficulty];
                ctx.beginPath();
                ctx.arc(currentPos.x * tileSize + tileSize / 2, currentPos.y * tileSize + tileSize / 2, tileSize / 2 * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                step++;
                setTimeout(() => { if (isAnimating) requestAnimationFrame(animationLoop); }, 50);
            }
            animationLoop();
        }

        // --- Event Handlers (updated for new features) ---
        async function handlePredict() {
            if (isAnimating) return;
            const inputSequence = gridToHRMSequence(grid, trafficGrid, startPos, endPos);
            lastHrmPrediction = await getHRMPrediction(inputSequence);
            if (lastHrmPrediction.length > 0) {
                animateVehicle(lastHrmPrediction);
                updateResults();
            }
        }

        async function handleCompareOracle() {
            if (isAnimating) return;
            
            statusEl.textContent = '‚öñÔ∏è Computing A* oracle and comparing...';
            compareOracleBtn.disabled = true;
            
            if (!lastHrmPrediction) {
                const inputSequence = gridToHRMSequence(grid, trafficGrid, startPos, endPos);
                lastHrmPrediction = await getHRMPrediction(inputSequence);
            }
            
            const vehicle = VEHICLE_CONFIG[currentDifficulty];
            lastOraclePath = solvePathAStar(trafficGrid, startPos, endPos, vehicle);
            
            compareOracleBtn.disabled = false;
            updateResults();
            
            if (lastOraclePath.length > 0) {
                animateVehicle(lastOraclePath);
            } else {
                statusEl.textContent = '‚ùå No valid path exists for this scenario';
            }
        }

        function updateResults() {
            if (!lastHrmPrediction && !lastOraclePath) return;
            
            resultsPanel.classList.remove('hidden');
            
            if (lastHrmPrediction) {
                const hrmCost = lastHrmPrediction.length > 0 ? calculatePathCost(lastHrmPrediction, trafficGrid) : 'N/A';
                hrmResult.innerHTML = `
                    <div>Steps: ${lastHrmPrediction.length}</div>
                    <div>Cost: ${hrmCost !== 'N/A' ? hrmCost.toFixed(1) : 'N/A'}</div>
                `;
            } else {
                hrmResult.innerHTML = '<div>Not computed</div>';
            }
            
            if (lastOraclePath) {
                const oracleCost = lastOraclePath.length > 0 ? calculatePathCost(lastOraclePath, trafficGrid) : 'N/A';
                oracleResult.innerHTML = `
                    <div>Steps: ${lastOraclePath.length}</div>
                    <div>Cost: ${oracleCost !== 'N/A' ? oracleCost.toFixed(1) : 'N/A'}</div>
                `;
            } else {
                oracleResult.innerHTML = '<div>Not computed</div>';
            }
            
            if (lastHrmPrediction && lastOraclePath) {
                const hrmValid = lastHrmPrediction.length > 0;
                const oracleValid = lastOraclePath.length > 0;
                
                if (!hrmValid && !oracleValid) {
                    matchResult.innerHTML = '<div class="text-gray-600">Both failed</div>';
                } else if (!hrmValid) {
                    matchResult.innerHTML = '<div class="text-red-600">HRM failed</div>';
                } else if (!oracleValid) {
                    matchResult.innerHTML = '<div class="text-orange-600">No valid path</div>';
                } else {
                    const hrmCost = calculatePathCost(lastHrmPrediction, trafficGrid);
                    const oracleCost = calculatePathCost(lastOraclePath, trafficGrid);
                    const ratio = hrmCost / oracleCost;
                    
                    if (ratio <= 1.05) {
                        matchResult.innerHTML = '<div class="text-green-600">‚úÖ Optimal</div>';
                    } else if (ratio <= 1.2) {
                        matchResult.innerHTML = '<div class="text-yellow-600">‚ö†Ô∏è Near-optimal</div>';
                    } else {
                        matchResult.innerHTML = '<div class="text-red-600">‚ùå Suboptimal</div>';
                    }
                }
            }
        }

        async function testModelConnection() {
            testConnectionBtn.disabled = true;
            modelStatusEl.textContent = 'Testing connection...';
            
            try {
                const response = await fetch('http://127.0.0.1:5000/health');
                
                if (response.ok) {
                    modelStatusEl.textContent = '‚úÖ HRM server connected and ready';
                    modelStatusEl.className = 'text-sm text-green-700';
                } else {
                    throw new Error('Server responded with error');
                }
            } catch (error) {
                modelStatusEl.textContent = '‚ùå Cannot connect to HRM server at http://127.0.0.1:5000';
                modelStatusEl.className = 'text-sm text-red-700';
            }
            
            testConnectionBtn.disabled = false;
        }
        
        function handleDifficultyChange(e) {
            if (e.target.tagName !== 'BUTTON') return;
            
            const newDifficulty = e.target.dataset.difficulty;
            currentDifficulty = newDifficulty;
            
            Array.from(difficultyButtons.children).forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-800');
            });
            
            e.target.classList.remove('bg-gray-200', 'text-gray-800');
            e.target.classList.add('bg-blue-500', 'text-white');
            
            statusEl.textContent = `Selected: ${VEHICLE_CONFIG[currentDifficulty].name}. Generate scenario or get HRM prediction.`;
            
            lastHrmPrediction = null;
            lastOraclePath = null;
            lastReasoningSteps = [];
            reasoningPanel.classList.add('hidden');
            resultsPanel.classList.add('hidden');
            animateReasoningBtn.disabled = true;
            
            if (grid.length > 0 && !isAnimating) {
                updateTrafficAndDraw();
            }
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, 800);
            canvas.width = size;
            canvas.height = size;
            tileSize = size / MAP_DIMENSIONS.width;
            if (grid.length > 0) updateTrafficAndDraw();
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            predictBtn.addEventListener('click', handlePredict);
            compareOracleBtn.addEventListener('click', handleCompareOracle);
            animateReasoningBtn.addEventListener('click', animateReasoning);
            testConnectionBtn.addEventListener('click', testModelConnection);
            generateMapBtn.addEventListener('click', () => {
                if (isAnimating) return;
                lastHrmPrediction = null;
                lastOraclePath = null;
                lastReasoningSteps = [];
                generateMap();
                statusEl.textContent = 'New scenario generated. Ready for HRM evaluation.';
            });
            difficultyButtons.addEventListener('click', handleDifficultyChange);
            timeSelector.addEventListener('change', () => {
                currentHour = parseInt(timeSelector.value);
                lastHrmPrediction = null;
                lastOraclePath = null;
                lastReasoningSteps = [];
                if (grid.length > 0 && !isAnimating) updateTrafficAndDraw();
            });
            
            difficultyButtons.querySelector(`[data-difficulty="${currentDifficulty}"]`).classList.add('bg-blue-500', 'text-white');
            generateMap();
            testModelConnection();
            statusEl.textContent = 'Enhanced HRM evaluation ready. Enable reasoning logs to see step-by-step thinking.';
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>