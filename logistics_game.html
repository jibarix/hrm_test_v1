<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Logistics Simulator - HRM Paper Compatible</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .btn { transition: all 0.2s ease-in-out; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
        .btn.active { transform: translateY(1px); background-color: #3b82f6 !important; color: white !important; }
        canvas { image-rendering: pixelated; border-radius: 0.5rem; display: block; margin: 0 auto; }
        .canvas-container { width: 100%; max-width: 800px; aspect-ratio: 1; margin: 0 auto; position: relative; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto bg-white rounded-xl shadow-lg p-4 sm:p-6">
        <div class="text-center mb-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800">City Logistics Simulator</h1>
            <p class="text-gray-500 mt-1">üß† HRM Paper-Compatible Dataset Generator (960 Train + 400 Test)</p>
        </div>

        <!-- Dataset Generation Controls -->
        <div class="flex flex-col gap-4 mb-4">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h3 class="font-semibold text-blue-800 mb-2">üìä Paper-Compatible Dataset Structure</h3>
                <div class="text-sm text-blue-700 space-y-1">
                    <div><strong>Train:</strong> 240 base scenarios √ó 4 vehicles = 960 examples</div>
                    <div><strong>Test:</strong> 100 base scenarios √ó 4 vehicles = 400 examples</div>
                    <div><strong>Method:</strong> Each base scenario ‚Üí systematic 4-vehicle variants</div>
                    <div><strong>Split:</strong> Completely separate base scenarios (no overlap)</div>
                    <div><strong>Output:</strong> 18 JSON files ready for HRM conversion</div>
                </div>
            </div>
            
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                <div class="flex items-center gap-2">
                    <span class="font-semibold text-gray-700">Vehicle:</span>
                    <div id="difficulty-buttons" class="flex flex-wrap gap-2">
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="easy">üö≤ Bike</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="normal">üöó Car</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="hard">üöê Van</button>
                        <button class="btn bg-gray-200 text-gray-800 px-4 py-2 rounded-lg shadow-md" data-difficulty="expert">üöõ Truck</button>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-semibold text-gray-700">Time:</span>
                    <select id="time-selector" class="bg-white border border-gray-300 rounded-lg px-3 py-2 shadow-md">
                        <option value="6">6:00 AM - Early Morning</option>
                        <option value="8" selected>8:00 AM - Rush Hour</option>
                        <option value="10">10:00 AM - Mid Morning</option>
                        <option value="12">12:00 PM - Lunch Hour</option>
                        <option value="14">2:00 PM - Afternoon</option>
                        <option value="17">5:00 PM - Evening Rush</option>
                        <option value="20">8:00 PM - Evening</option>
                        <option value="23">11:00 PM - Late Night</option>
                    </select>
                </div>
            </div>
            
            <div class="text-center">
                <button id="generate-btn" class="btn bg-green-500 text-white font-bold px-6 py-2 rounded-lg shadow-lg">
                    üèôÔ∏è Find Route in City
                </button>
                <button id="generate-paper-dataset-btn" class="btn bg-purple-500 text-white font-bold px-6 py-2 rounded-lg shadow-lg ml-2">
                    üìä Generate Paper Dataset
                </button>
                <button id="download-data-btn" class="btn bg-blue-500 text-white font-bold px-4 py-2 rounded-lg shadow-lg ml-2" disabled>
                    üì• Download HRM Data
                </button>
            </div>
            
            <div id="data-progress" class="text-center text-sm text-gray-600 mt-2 hidden">
                <div class="mb-2">
                    <div class="text-sm font-medium">Generating Base Scenarios: <span id="progress-text">0/340</span></div>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div id="progress-bar" class="bg-blue-600 h-2 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
                <div class="text-xs text-gray-500">
                    Train: <span id="train-progress">0/240</span> base scenarios | 
                    Test: <span id="test-progress">0/100</span> base scenarios |
                    Total examples: <span id="total-examples">0/1360</span>
                </div>
            </div>
        </div>
        
        <p id="status" class="text-center text-gray-600 h-6 mb-4"></p>

        <!-- Legend -->
        <div class="bg-gray-50 rounded-lg p-4 mb-4">
            <h3 class="text-lg font-semibold text-gray-800 mb-3 text-center">üèôÔ∏è City Traffic Map Legend</h3>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-2 text-sm">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #4a5568;"></div>
                    <span>Buildings/City Park</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #d1d5db;"></div>
                    <span>Side Streets</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #9ca3af;"></div>
                    <span>Major Avenues</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #a78bfa;"></div>
                    <span>Main Diagonal</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #f59e0b;"></div>
                    <span>Heavy Traffic</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #dc2626;"></div>
                    <span>Road Closure</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #10b981;"></div>
                    <span>Start Point</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #ef4444;"></div>
                    <span>Destination</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: #3b82f6;"></div>
                    <span>Optimal Route</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full" style="background-color: #34d399;"></div>
                    <span>Vehicle</span>
                </div>
            </div>
            <div class="mt-3 pt-3 border-t border-gray-200">
                <div class="text-xs text-gray-600 space-y-1">
                    <div><span class="font-medium text-purple-600">üß† HRM Training:</span> Each base scenario generates 4 vehicle variants (bike/car/van/truck)</div>
                    <div><span class="font-medium text-blue-600">üìä Paper Method:</span> Separate base scenarios for train/test (no scenario overlap)</div>
                    <div><span class="font-medium text-green-600">üéØ Output:</span> 960 train + 400 test examples with systematic augmentation</div>
                </div>
            </div>
        </div>

        <!-- Canvas for visualization -->
        <div class="canvas-container bg-gray-800 rounded-lg shadow-inner">
             <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const MAP_DIMENSIONS = { width: 40, height: 40 };

        const COLORS = {
            OBSTACLE: '#4a5568',    // Dark Gray
            SMALL_ROAD: '#d1d5db',  // Light Gray
            LARGE_ROAD: '#9ca3af',  // Medium Gray
            TRAFFIC_JAM: '#f59e0b', // Amber
            ROAD_CLOSURE: '#dc2626', // Red
            START: '#10b981',       // Emerald
            END: '#ef4444',         // Red
            PATH: '#3b82f6',        // Blue
            VEHICLE: {
                easy: '#34d399',   // Bike - Green
                normal: '#60a5fa', // Car - Blue
                hard: '#facc15',   // Van - Yellow
                expert: '#f87171', // Truck - Red
            }
        };

        const TILE_TYPES = {
            OBSTACLE: 0,
            SMALL_ROAD: 1,
            LARGE_ROAD: 2,
            DIAGONAL: 3,  // Main diagonal thoroughfare
        };

        const VEHICLE_CONFIG = {
            easy:   { name: 'Bike',   allowed_roads: [TILE_TYPES.SMALL_ROAD, TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            normal: { name: 'Car',    allowed_roads: [TILE_TYPES.SMALL_ROAD, TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            hard:   { name: 'Van',    allowed_roads: [TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] },
            expert: { name: 'Truck',  allowed_roads: [TILE_TYPES.LARGE_ROAD] },
        };
        
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generate-btn');
        const statusEl = document.getElementById('status');
        const difficultyButtons = document.getElementById('difficulty-buttons');
        const timeSelector = document.getElementById('time-selector');
        const generatePaperDatasetBtn = document.getElementById('generate-paper-dataset-btn');
        const downloadDataBtn = document.getElementById('download-data-btn');
        const dataProgress = document.getElementById('data-progress');
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const trainProgress = document.getElementById('train-progress');
        const testProgress = document.getElementById('test-progress');
        const totalExamples = document.getElementById('total-examples');

        // --- Game State ---
        let currentDifficulty = 'easy';
        let currentHour = 8;
        let grid = [];
        let startPos = null;
        let endPos = null;
        let isAnimating = false;
        let tileSize = 1;

        // --- HRM Dataset Storage ---
        let paperDataset = null;

        // --- HRM Token Mapping ---
        const HRM_TOKEN_MAP = {
            PAD: 0,           // Padding token
            OBSTACLE: 1,      // Buildings/City Park
            SMALL_ROAD: 2,    // Side Streets  
            LARGE_ROAD: 3,    // Major Avenues
            DIAGONAL: 4,      // Main diagonal thoroughfare
            TRAFFIC_JAM: 5,   // Heavy Traffic
            ROAD_CLOSURE: 6,  // Road Closure
            START: 7,         // Start Point
            END: 8,           // End Point
            PATH: 9           // Optimal Route
        };

        // --- Base Scenario Generation ---
        function generateBaseScenario(scenarioId, isTrainSet) {
            // Generate a unique base scenario (deterministic based on scenarioId)
            const rng = createSeededRNG(scenarioId + (isTrainSet ? 1000000 : 2000000));
            
            // Generate base map structure
            const baseGrid = generateMapWithSeed(rng);
            
            // Generate start/end positions
            const { start, end } = generateStartEndWithSeed(baseGrid, rng);
            
            // Generate time and traffic conditions
            const hour = [6, 8, 10, 12, 14, 17, 20, 23][Math.floor(rng() * 8)];
            
            return {
                id: scenarioId,
                isTrainSet: isTrainSet,
                baseGrid: baseGrid,
                startPos: start,
                endPos: end,
                hour: hour,
                trafficSeed: Math.floor(rng() * 1000000)
            };
        }

        // --- Vehicle Variant Generation (ROBUST VERSION) ---
        function generateVehicleVariant(baseScenario, vehicleType) {
            const vehicle = VEHICLE_CONFIG[vehicleType];
            let optimalPath = [];
            let trafficGrid = null;
            let attempts = 0;
            const maxAttempts = 5;
            
            // Try multiple traffic configurations to ensure path exists
            while (optimalPath.length === 0 && attempts < maxAttempts) {
                // Reduce traffic intensity for restricted vehicles on later attempts
                const trafficReduction = attempts * 0.2;
                trafficGrid = addTrafficWithSeedAndReduction(baseScenario.baseGrid, baseScenario.hour, 
                                                           baseScenario.trafficSeed + attempts, trafficReduction);
                
                // Use A* to find optimal path for this vehicle
                optimalPath = solvePath(trafficGrid, baseScenario.startPos, baseScenario.endPos, vehicle);
                attempts++;
            }
            
            // Fallback: Use base grid without traffic if still no path
            if (optimalPath.length === 0) {
                trafficGrid = baseScenario.baseGrid.map(row => [...row]); // No traffic
                optimalPath = solvePath(trafficGrid, baseScenario.startPos, baseScenario.endPos, vehicle);
            }
            
            // Final fallback: relax vehicle restrictions temporarily
            if (optimalPath.length === 0) {
                const relaxedVehicle = {
                    ...vehicle,
                    allowed_roads: [TILE_TYPES.SMALL_ROAD, TILE_TYPES.LARGE_ROAD, TILE_TYPES.DIAGONAL] // Allow all roads
                };
                optimalPath = solvePath(trafficGrid, baseScenario.startPos, baseScenario.endPos, relaxedVehicle);
                console.warn(`Had to relax restrictions for ${vehicleType} in scenario ${baseScenario.id}`);
            }
            
            if (optimalPath.length === 0) {
                console.error(`Failed to generate path for ${vehicleType} in scenario ${baseScenario.id}`);
                return null; // Still failed - this should be very rare
            }
            
            // Convert to HRM format
            const inputSequence = gridToHRMSequence(baseScenario.baseGrid, trafficGrid, baseScenario.startPos, baseScenario.endPos, []);
            const outputSequence = pathToHRMSequence(baseScenario.baseGrid, optimalPath);
            
            return {
                baseScenarioId: baseScenario.id,
                isTrainSet: baseScenario.isTrainSet,
                vehicle: vehicleType,
                hour: baseScenario.hour,
                input: inputSequence,
                output: outputSequence,
                pathLength: optimalPath.length,
                cost: calculatePathCost(optimalPath, trafficGrid),
                attempts: attempts // For debugging
            };
        }

        // --- Enhanced Traffic Generation with Reduction ---
        function addTrafficWithSeedAndReduction(baseGrid, hour, trafficSeed, reduction = 0) {
            const rng = createSeededRNG(trafficSeed);
            let trafficGrid = baseGrid.map(row => [...row]);
            
            let trafficIntensity = 0;
            let constructionActive = false;
            
            if (hour >= 7 && hour <= 9) {
                trafficIntensity = Math.max(0, 0.4 - reduction);
            } else if (hour >= 17 && hour <= 19) {
                trafficIntensity = Math.max(0, 0.45 - reduction);
            } else if (hour >= 12 && hour <= 13) {
                trafficIntensity = Math.max(0, 0.25 - reduction);
            } else if (hour >= 2 && hour <= 5) {
                constructionActive = reduction < 0.5; // Disable construction if high reduction
                trafficIntensity = Math.max(0, 0.1 - reduction);
            } else {
                trafficIntensity = Math.max(0, 0.1 - reduction);
            }

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const roadType = baseGrid[y][x];
                    
                    if (roadType === TILE_TYPES.LARGE_ROAD || roadType === TILE_TYPES.DIAGONAL) {
                        if (constructionActive && rng() < 0.05) {
                            trafficGrid[y][x] = 'ROAD_CLOSURE';
                        } else if (rng() < trafficIntensity) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    } else if (roadType === TILE_TYPES.SMALL_ROAD) {
                        if (rng() < trafficIntensity * 0.3) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    }
                }
            }

            return trafficGrid;
        }

        // --- Paper-Compatible Dataset Generation ---
        async function generatePaperCompatibleDataset() {
            const trainBaseCount = 240;  // 240 √ó 4 = 960 train examples
            const testBaseCount = 100;   // 100 √ó 4 = 400 test examples
            const vehicleTypes = ['easy', 'normal', 'hard', 'expert'];
            
            paperDataset = {
                train: {
                    inputs: [],
                    labels: [],
                    puzzle_identifiers: [],
                    puzzle_indices: [0],
                    group_indices: [0],
                    base_scenario_ids: [],
                    vehicle_types: []
                },
                test: {
                    inputs: [],
                    labels: [],
                    puzzle_identifiers: [],
                    puzzle_indices: [0],
                    group_indices: [0],
                    base_scenario_ids: [],
                    vehicle_types: []
                }
            };
            
            let totalBaseScenarios = trainBaseCount + testBaseCount;
            let processedBaseScenarios = 0;
            let totalExampleCount = 0;
            let failedVariants = 0;
            
            // Show progress
            dataProgress.classList.remove('hidden');
            generatePaperDatasetBtn.disabled = true;
            
            // Generate train base scenarios
            for (let i = 0; i < trainBaseCount; i++) {
                const baseScenario = generateBaseScenario(i, true);
                let validVariants = 0;
                
                // Generate 4 vehicle variants for this base scenario
                for (const vehicleType of vehicleTypes) {
                    const variant = generateVehicleVariant(baseScenario, vehicleType);
                    
                    if (variant) {
                        paperDataset.train.inputs.push(variant.input);
                        paperDataset.train.labels.push(variant.output);
                        paperDataset.train.puzzle_identifiers.push(0); // All same puzzle type
                        paperDataset.train.base_scenario_ids.push(baseScenario.id);
                        paperDataset.train.vehicle_types.push(vehicleType);
                        
                        totalExampleCount++;
                        validVariants++;
                        
                        // Update puzzle indices (each example is its own "puzzle")
                        paperDataset.train.puzzle_indices.push(totalExampleCount);
                    } else {
                        failedVariants++;
                        console.warn(`Failed to generate variant for ${vehicleType} in train scenario ${baseScenario.id}`);
                    }
                }
                
                // Only count base scenarios that generated at least 2 valid variants
                if (validVariants >= 2) {
                    // Add group boundary (one group per base scenario)
                    paperDataset.train.group_indices.push(paperDataset.train.puzzle_identifiers.length);
                }
                
                processedBaseScenarios++;
                updateProgress(processedBaseScenarios, totalBaseScenarios, 
                              i + 1, trainBaseCount, 0, testBaseCount, totalExampleCount);
                
                // Allow UI to update
                if (i % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Generate test base scenarios
            for (let i = 0; i < testBaseCount; i++) {
                const baseScenario = generateBaseScenario(i + 10000, false); // Different seed space
                let validVariants = 0;
                
                // Generate 4 vehicle variants for this base scenario
                for (const vehicleType of vehicleTypes) {
                    const variant = generateVehicleVariant(baseScenario, vehicleType);
                    
                    if (variant) {
                        paperDataset.test.inputs.push(variant.input);
                        paperDataset.test.labels.push(variant.output);
                        paperDataset.test.puzzle_identifiers.push(0);
                        paperDataset.test.base_scenario_ids.push(baseScenario.id);
                        paperDataset.test.vehicle_types.push(vehicleType);
                        
                        totalExampleCount++;
                        validVariants++;
                        
                        paperDataset.test.puzzle_indices.push(paperDataset.test.puzzle_identifiers.length);
                    } else {
                        failedVariants++;
                        console.warn(`Failed to generate variant for ${vehicleType} in test scenario ${baseScenario.id}`);
                    }
                }
                
                if (validVariants >= 2) {
                    paperDataset.test.group_indices.push(paperDataset.test.puzzle_identifiers.length);
                }
                
                processedBaseScenarios++;
                updateProgress(processedBaseScenarios, totalBaseScenarios, 
                              trainBaseCount, trainBaseCount, i + 1, testBaseCount, totalExampleCount);
                
                if (i % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Hide progress and enable download
            dataProgress.classList.add('hidden');
            generatePaperDatasetBtn.disabled = false;
            downloadDataBtn.disabled = false;
            
            const trainCount = paperDataset.train.inputs.length;
            const testCount = paperDataset.test.inputs.length;
            
            statusEl.textContent = `‚úÖ Generated Paper Dataset: ${trainCount} train + ${testCount} test examples (${processedBaseScenarios} base scenarios, ${failedVariants} failed variants)`;
            
            console.log(`üìä Paper Dataset Summary:
Train: ${trainCount} examples from ${trainBaseCount} base scenarios
Test: ${testCount} examples from ${testBaseCount} base scenarios  
Total: ${totalExampleCount} examples
Failed variants: ${failedVariants}
Systematic augmentation: Each base scenario ‚Üí up to 4 vehicle variants`);
        }

        function updateProgress(processed, total, trainDone, trainTotal, testDone, testTotal, examples) {
            const percentage = (processed / total) * 100;
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${processed}/${total}`;
            trainProgress.textContent = `${trainDone}/${trainTotal}`;
            testProgress.textContent = `${testDone}/${testTotal}`;
            totalExamples.textContent = `${examples}/1360`;
        }

        // --- Seeded Random Number Generator ---
        function createSeededRNG(seed) {
            let x = seed;
            return function() {
                x = (x * 1103515245 + 12345) & 0x7fffffff;
                return x / 0x7fffffff;
            };
        }

        // --- Seeded Map Generation ---
        function generateMapWithSeed(rng) {
            const localGrid = Array(MAP_DIMENSIONS.height).fill(null).map(() => Array(MAP_DIMENSIONS.width).fill(TILE_TYPES.OBSTACLE));

            // Generate deterministic road network based on seed
            const avenues = [3, 8, 13, 18, 23, 28, 33, 37];
            for (let avenue of avenues) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (avenue < MAP_DIMENSIONS.width) {
                        localGrid[y][avenue] = TILE_TYPES.LARGE_ROAD;
                        if (avenue + 1 < MAP_DIMENSIONS.width) {
                            localGrid[y][avenue + 1] = TILE_TYPES.LARGE_ROAD;
                        }
                    }
                }
            }

            const streets = [2, 6, 10, 14, 18, 22, 26, 30, 34, 37];
            for (let street of streets) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (street < MAP_DIMENSIONS.height) {
                        localGrid[street][x] = TILE_TYPES.LARGE_ROAD;
                    }
                }
            }

            // Add side streets
            for (let y = 4; y < MAP_DIMENSIONS.height; y += 4) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (localGrid[y][x] === TILE_TYPES.OBSTACLE) {
                        localGrid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            for (let x = 5; x < MAP_DIMENSIONS.width; x += 6) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (localGrid[y][x] === TILE_TYPES.OBSTACLE) {
                        localGrid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            // Add main diagonal
            for (let i = 0; i < MAP_DIMENSIONS.width - 5; i++) {
                const x = i;
                const y = Math.floor((i * MAP_DIMENSIONS.height) / MAP_DIMENSIONS.width);
                if (y < MAP_DIMENSIONS.height && x < MAP_DIMENSIONS.width) {
                    localGrid[y][x] = TILE_TYPES.DIAGONAL;
                    if (y + 1 < MAP_DIMENSIONS.height) localGrid[y + 1][x] = TILE_TYPES.DIAGONAL;
                }
            }

            // Add Central Park
            const parkStartX = Math.floor(MAP_DIMENSIONS.width * 0.4);
            const parkEndX = Math.floor(MAP_DIMENSIONS.width * 0.65);
            const parkStartY = Math.floor(MAP_DIMENSIONS.height * 0.15);
            const parkEndY = Math.floor(MAP_DIMENSIONS.height * 0.45);
            
            for (let y = parkStartY; y < parkEndY; y++) {
                for (let x = parkStartX; x < parkEndX; x++) {
                    if (x < MAP_DIMENSIONS.width && y < MAP_DIMENSIONS.height) {
                        localGrid[y][x] = TILE_TYPES.OBSTACLE;
                    }
                }
            }

            return localGrid;
        }

        function generateStartEndWithSeed(baseGrid, rng) {
            const roadPositions = [];
            
            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (baseGrid[y][x] !== TILE_TYPES.OBSTACLE) {
                        const edgeDistance = Math.min(x, y, MAP_DIMENSIONS.width - 1 - x, MAP_DIMENSIONS.height - 1 - y);
                        if (edgeDistance >= 2) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
            }

            if (roadPositions.length >= 2) {
                let attempts = 0;
                let start, end;
                
                do {
                    const startIdx = Math.floor(rng() * roadPositions.length);
                    start = roadPositions[startIdx];
                    
                    const validEndPositions = roadPositions.filter(pos => {
                        const distance = Math.abs(pos.x - start.x) + Math.abs(pos.y - start.y);
                        return distance >= 15 && distance <= 50;
                    });
                    
                    if (validEndPositions.length > 0) {
                        end = validEndPositions[Math.floor(rng() * validEndPositions.length)];
                        break;
                    }
                    
                    attempts++;
                } while (attempts < 10);
                
                if (attempts >= 10) {
                    start = roadPositions[0];
                    end = roadPositions[roadPositions.length - 1];
                }
                
                return { start, end };
            }
            
            return { 
                start: { x: 5, y: 5 }, 
                end: { x: MAP_DIMENSIONS.width - 5, y: MAP_DIMENSIONS.height - 5 } 
            };
        }

        function addTrafficWithSeed(baseGrid, hour, trafficSeed) {
            const rng = createSeededRNG(trafficSeed);
            let trafficGrid = baseGrid.map(row => [...row]);
            
            let trafficIntensity = 0;
            let constructionActive = false;
            
            if (hour >= 7 && hour <= 9) {
                trafficIntensity = 0.4;
            } else if (hour >= 17 && hour <= 19) {
                trafficIntensity = 0.45;
            } else if (hour >= 12 && hour <= 13) {
                trafficIntensity = 0.25;
            } else if (hour >= 2 && hour <= 5) {
                constructionActive = true;
                trafficIntensity = 0.1;
            } else {
                trafficIntensity = 0.1;
            }

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const roadType = baseGrid[y][x];
                    
                    if (roadType === TILE_TYPES.LARGE_ROAD || roadType === TILE_TYPES.DIAGONAL) {
                        if (constructionActive && rng() < 0.05) {
                            trafficGrid[y][x] = 'ROAD_CLOSURE';
                        } else if (rng() < trafficIntensity) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    } else if (roadType === TILE_TYPES.SMALL_ROAD) {
                        if (rng() < trafficIntensity * 0.3) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    }
                }
            }

            return trafficGrid;
        }

        // --- Download Paper Dataset (FIXED: ZIP DOWNLOAD) ---
        async function downloadPaperDataset() {
            if (!paperDataset) {
                alert('No paper dataset to download. Generate dataset first!');
                return;
            }
            
            // Show progress
            downloadDataBtn.textContent = 'üì¶ Creating ZIP...';
            downloadDataBtn.disabled = true;
            
            try {
                // Create metadata for train and test
                const createMetadata = (split, data) => ({
                    seq_len: MAP_DIMENSIONS.width * MAP_DIMENSIONS.height,
                    vocab_size: Object.keys(HRM_TOKEN_MAP).length,
                    pad_id: 0,
                    ignore_label_id: 0,
                    blank_identifier_id: 0,
                    num_puzzle_identifiers: 1,
                    total_groups: data.group_indices.length - 1,
                    mean_puzzle_examples: data.inputs.length / (data.group_indices.length - 1),
                    sets: ["all"],
                    task: "city_logistics_routing",
                    map_dimensions: MAP_DIMENSIONS,
                    token_mapping: HRM_TOKEN_MAP,
                    generation_method: "paper_compatible",
                    split: split
                });
                
                // Create ZIP file
                const zip = new JSZip();
                
                // Generate files for both train and test
                for (const [split, data] of Object.entries(paperDataset)) {
                    const metadata = createMetadata(split, data);
                    
                    zip.file(`city_routing_paper_${split}_dataset.json`, JSON.stringify(metadata, null, 2));
                    zip.file(`city_routing_paper_${split}_all__inputs.json`, JSON.stringify(data.inputs));
                    zip.file(`city_routing_paper_${split}_all__labels.json`, JSON.stringify(data.labels));
                    zip.file(`city_routing_paper_${split}_all__puzzle_identifiers.json`, JSON.stringify(data.puzzle_identifiers));
                    zip.file(`city_routing_paper_${split}_all__puzzle_indices.json`, JSON.stringify(data.puzzle_indices));
                    zip.file(`city_routing_paper_${split}_all__group_indices.json`, JSON.stringify(data.group_indices));
                    
                    // Additional metadata files for analysis
                    zip.file(`city_routing_paper_${split}_all__base_scenario_ids.json`, JSON.stringify(data.base_scenario_ids));
                    zip.file(`city_routing_paper_${split}_all__vehicle_types.json`, JSON.stringify(data.vehicle_types));
                }
                
                // Global identifier mapping
                zip.file('city_routing_paper_identifiers.json', JSON.stringify(["<blank>"]));
                
                // Dataset summary
                const summary = {
                    method: "paper_compatible_generation",
                    train_examples: paperDataset.train.inputs.length,
                    test_examples: paperDataset.test.inputs.length,
                    base_scenarios_train: 240,
                    base_scenarios_test: 100,
                    systematic_augmentation: "4_vehicle_variants_per_base_scenario",
                    vehicles: ["easy", "normal", "hard", "expert"],
                    no_overlap: "train_test_base_scenarios_completely_separate"
                };
                zip.file('city_routing_paper_dataset_summary.json', JSON.stringify(summary, null, 2));
                
                // Generate and download ZIP
                const content = await zip.generateAsync({type: "blob"});
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'city_logistics_hrm_dataset.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log(`üì¶ Downloaded ZIP file with 18 files for HRM paper-compatible dataset`);
                alert(`Downloaded HRM Paper Dataset ZIP!\n\n‚úÖ Train: ${paperDataset.train.inputs.length} examples\n‚úÖ Test: ${paperDataset.test.inputs.length} examples\n‚úÖ 18 JSON files in ZIP ready for conversion\n\nNext: Extract ZIP and convert to .npy format for HRM training`);
                
            } catch (error) {
                console.error('Error creating ZIP:', error);
                alert('Error creating ZIP file. Please try again.');
            } finally {
                downloadDataBtn.textContent = 'üì• Download HRM Data';
                downloadDataBtn.disabled = false;
            }
        }

        // --- Core Functions (keep existing implementations) ---
        function generateMap() {
            grid = Array(MAP_DIMENSIONS.height).fill(null).map(() => Array(MAP_DIMENSIONS.width).fill(TILE_TYPES.OBSTACLE));

            const avenues = [3, 8, 13, 18, 23, 28, 33, 37];
            for (let avenue of avenues) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (avenue < MAP_DIMENSIONS.width) {
                        grid[y][avenue] = TILE_TYPES.LARGE_ROAD;
                        if (avenue + 1 < MAP_DIMENSIONS.width) {
                            grid[y][avenue + 1] = TILE_TYPES.LARGE_ROAD;
                        }
                    }
                }
            }

            const streets = [2, 6, 10, 14, 18, 22, 26, 30, 34, 37];
            for (let street of streets) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (street < MAP_DIMENSIONS.height) {
                        grid[street][x] = TILE_TYPES.LARGE_ROAD;
                    }
                }
            }

            for (let y = 4; y < MAP_DIMENSIONS.height; y += 4) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (grid[y][x] === TILE_TYPES.OBSTACLE) {
                        grid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            for (let x = 5; x < MAP_DIMENSIONS.width; x += 6) {
                for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                    if (grid[y][x] === TILE_TYPES.OBSTACLE) {
                        grid[y][x] = TILE_TYPES.SMALL_ROAD;
                    }
                }
            }

            for (let i = 0; i < MAP_DIMENSIONS.width - 5; i++) {
                const x = i;
                const y = Math.floor((i * MAP_DIMENSIONS.height) / MAP_DIMENSIONS.width);
                if (y < MAP_DIMENSIONS.height && x < MAP_DIMENSIONS.width) {
                    grid[y][x] = TILE_TYPES.DIAGONAL;
                    if (y + 1 < MAP_DIMENSIONS.height) grid[y + 1][x] = TILE_TYPES.DIAGONAL;
                }
            }

            const parkStartX = Math.floor(MAP_DIMENSIONS.width * 0.4);
            const parkEndX = Math.floor(MAP_DIMENSIONS.width * 0.65);
            const parkStartY = Math.floor(MAP_DIMENSIONS.height * 0.15);
            const parkEndY = Math.floor(MAP_DIMENSIONS.height * 0.45);
            
            for (let y = parkStartY; y < parkEndY; y++) {
                for (let x = parkStartX; x < parkEndX; x++) {
                    if (x < MAP_DIMENSIONS.width && y < MAP_DIMENSIONS.height) {
                        grid[y][x] = TILE_TYPES.OBSTACLE;
                    }
                }
            }

            placeStartAndEnd();
        }

        function placeStartAndEnd() {
            const roadPositions = [];
            
            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    if (grid[y][x] !== TILE_TYPES.OBSTACLE) {
                        const edgeDistance = Math.min(x, y, MAP_DIMENSIONS.width - 1 - x, MAP_DIMENSIONS.height - 1 - y);
                        if (edgeDistance >= 2) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
            }

            if (roadPositions.length >= 2) {
                let attempts = 0;
                do {
                    const startIdx = Math.floor(Math.random() * roadPositions.length);
                    startPos = roadPositions[startIdx];
                    
                    const validEndPositions = roadPositions.filter(pos => {
                        const distance = Math.abs(pos.x - startPos.x) + Math.abs(pos.y - startPos.y);
                        return distance >= 15 && distance <= 50;
                    });
                    
                    if (validEndPositions.length > 0) {
                        endPos = validEndPositions[Math.floor(Math.random() * validEndPositions.length)];
                        break;
                    }
                    
                    attempts++;
                } while (attempts < 10);
                
                if (attempts >= 10) {
                    startPos = roadPositions[0];
                    endPos = roadPositions[roadPositions.length - 1];
                }
            } else {
                startPos = { x: 5, y: 5 };
                endPos = { x: MAP_DIMENSIONS.width - 5, y: MAP_DIMENSIONS.height - 5 };
            }
        }

        function addTraffic(baseGrid, hour) {
            let trafficGrid = baseGrid.map(row => [...row]);
            
            let trafficIntensity = 0;
            let constructionActive = false;
            
            if (hour >= 7 && hour <= 9) {
                trafficIntensity = 0.4;
            } else if (hour >= 17 && hour <= 19) {
                trafficIntensity = 0.45;
            } else if (hour >= 12 && hour <= 13) {
                trafficIntensity = 0.25;
            } else if (hour >= 2 && hour <= 5) {
                constructionActive = true;
                trafficIntensity = 0.1;
            } else {
                trafficIntensity = 0.1;
            }

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const roadType = baseGrid[y][x];
                    
                    if (roadType === TILE_TYPES.LARGE_ROAD || roadType === TILE_TYPES.DIAGONAL) {
                        if (constructionActive && Math.random() < 0.05) {
                            trafficGrid[y][x] = 'ROAD_CLOSURE';
                        } else if (Math.random() < trafficIntensity) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    } else if (roadType === TILE_TYPES.SMALL_ROAD) {
                        if (Math.random() < trafficIntensity * 0.3) {
                            trafficGrid[y][x] = 'TRAFFIC_JAM';
                        }
                    }
                }
            }

            return trafficGrid;
        }

        function gridToHRMSequence(baseGrid, trafficGrid, startPos, endPos, optimalPath) {
            const pathSet = new Set(optimalPath.map(p => `${p.x},${p.y}`));
            const sequence = new Array(MAP_DIMENSIONS.width * MAP_DIMENSIONS.height);
            
            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    const idx = y * MAP_DIMENSIONS.width + x;
                    const coord = `${x},${y}`;
                    
                    if (startPos && startPos.x === x && startPos.y === y) {
                        sequence[idx] = HRM_TOKEN_MAP.START;
                    } else if (endPos && endPos.x === x && endPos.y === y) {
                        sequence[idx] = HRM_TOKEN_MAP.END;
                    } else if (pathSet.has(coord)) {
                        sequence[idx] = HRM_TOKEN_MAP.PATH;
                    } else if (trafficGrid[y][x] === 'TRAFFIC_JAM') {
                        sequence[idx] = HRM_TOKEN_MAP.TRAFFIC_JAM;
                    } else if (trafficGrid[y][x] === 'ROAD_CLOSURE') {
                        sequence[idx] = HRM_TOKEN_MAP.ROAD_CLOSURE;
                    } else {
                        switch (baseGrid[y][x]) {
                            case TILE_TYPES.OBSTACLE: sequence[idx] = HRM_TOKEN_MAP.OBSTACLE; break;
                            case TILE_TYPES.SMALL_ROAD: sequence[idx] = HRM_TOKEN_MAP.SMALL_ROAD; break;
                            case TILE_TYPES.LARGE_ROAD: sequence[idx] = HRM_TOKEN_MAP.LARGE_ROAD; break;
                            case TILE_TYPES.DIAGONAL: sequence[idx] = HRM_TOKEN_MAP.DIAGONAL; break;
                            default: sequence[idx] = HRM_TOKEN_MAP.OBSTACLE;
                        }
                    }
                }
            }
            
            return sequence;
        }

        function pathToHRMSequence(baseGrid, path) {
            const sequence = new Array(MAP_DIMENSIONS.width * MAP_DIMENSIONS.height).fill(HRM_TOKEN_MAP.PAD);
            
            for (const pos of path) {
                const idx = pos.y * MAP_DIMENSIONS.width + pos.x;
                sequence[idx] = HRM_TOKEN_MAP.PATH;
            }
            
            return sequence;
        }

        function drawMap(dynamicGrid, path = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < MAP_DIMENSIONS.height; y++) {
                for (let x = 0; x < MAP_DIMENSIONS.width; x++) {
                    let color;
                    switch (dynamicGrid[y][x]) {
                        case TILE_TYPES.OBSTACLE: color = COLORS.OBSTACLE; break;
                        case TILE_TYPES.SMALL_ROAD: color = COLORS.SMALL_ROAD; break;
                        case TILE_TYPES.LARGE_ROAD: color = COLORS.LARGE_ROAD; break;
                        case TILE_TYPES.DIAGONAL: color = '#a78bfa'; break;
                        case 'TRAFFIC_JAM': color = COLORS.TRAFFIC_JAM; break;
                        case 'ROAD_CLOSURE': color = COLORS.ROAD_CLOSURE; break;
                        default: color = COLORS.OBSTACLE;
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            
            if (path.length > 0) {
                ctx.fillStyle = COLORS.PATH;
                path.forEach(p => {
                    ctx.fillRect(p.x * tileSize, p.y * tileSize, tileSize, tileSize);
                });
            }

            if (startPos) {
                ctx.fillStyle = COLORS.START;
                ctx.fillRect(startPos.x * tileSize, startPos.y * tileSize, tileSize, tileSize);
            }
            if (endPos) {
                ctx.fillStyle = COLORS.END;
                ctx.fillRect(endPos.x * tileSize, endPos.y * tileSize, tileSize, tileSize);
            }
        }

        function animateVehicle(dynamicGrid, path) {
            if (path.length === 0) {
                isAnimating = false;
                statusEl.textContent = 'No route available! Try a different vehicle or time.';
                return;
            }
            isAnimating = true;
            let step = 0;

            function animationLoop() {
                if (step >= path.length) {
                    isAnimating = false;
                    const totalCost = calculatePathCost(path, dynamicGrid);
                    statusEl.textContent = `üéØ Arrived! Route: ${path.length} blocks, Travel time: ${totalCost.toFixed(1)} minutes`;
                    return;
                }
                
                drawMap(dynamicGrid, path.slice(0, step + 1));
                
                const currentPos = path[step];
                ctx.fillStyle = COLORS.VEHICLE[currentDifficulty];
                ctx.beginPath();
                ctx.arc(
                    currentPos.x * tileSize + tileSize / 2, 
                    currentPos.y * tileSize + tileSize / 2, 
                    tileSize / 2 * 0.8, 
                    0, 2 * Math.PI
                );
                ctx.fill();

                step++;
                setTimeout(() => {
                    if (isAnimating) {
                        requestAnimationFrame(animationLoop);
                    }
                }, 100);
            }
            animationLoop();
        }

        // --- A* Pathfinding (keep existing implementation) ---
        function solvePath(dynamicGrid, start, end, vehicle) {
            const openSet = [start];
            const cameFrom = {};
            const closedSet = new Set();
            
            const gScore = {};
            const fScore = {};

            const startKey = `${start.x},${start.y}`;
            gScore[startKey] = 0;
            fScore[startKey] = heuristic(start, end);

            while (openSet.length > 0) {
                let current = openSet[0];
                let currentIndex = 0;
                for (let i = 1; i < openSet.length; i++) {
                    const currentF = fScore[`${openSet[i].x},${openSet[i].y}`] || Infinity;
                    const bestF = fScore[`${current.x},${current.y}`] || Infinity;
                    if (currentF < bestF) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }

                if (current.x === end.x && current.y === end.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(currentIndex, 1);
                closedSet.add(`${current.x},${current.y}`);
                
                const neighbors = getNeighbors(current, dynamicGrid, vehicle);
                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    const currentKey = `${current.x},${current.y}`;
                    
                    if (closedSet.has(neighborKey)) continue;
                    
                    const cost = getCost(dynamicGrid[neighbor.y][neighbor.x]);
                    const tentativeGScore = (gScore[currentKey] || 0) + cost;

                    if (tentativeGScore < (gScore[neighborKey] || Infinity)) {
                        cameFrom[neighborKey] = current;
                        gScore[neighborKey] = tentativeGScore;
                        fScore[neighborKey] = gScore[neighborKey] + heuristic(neighbor, end);
                        
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return [];
        }
        
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(node, dynamicGrid, vehicle) {
            const neighbors = [];
            const dirs = [{x:0, y:1}, {x:0, y:-1}, {x:1, y:0}, {x:-1, y:0}];
            for(const dir of dirs) {
                const nextX = node.x + dir.x;
                const nextY = node.y + dir.y;
                if(nextX >= 0 && nextX < MAP_DIMENSIONS.width && nextY >= 0 && nextY < MAP_DIMENSIONS.height) {
                    const tileType = dynamicGrid[nextY][nextX];
                    
                    if (tileType !== TILE_TYPES.OBSTACLE && tileType !== 'ROAD_CLOSURE') {
                        if (vehicle.allowed_roads.includes(tileType) || tileType === 'TRAFFIC_JAM') {
                            neighbors.push({x: nextX, y: nextY});
                        }
                    }
                }
            }
            return neighbors;
        }

        function getCost(tileType) {
            switch(tileType) {
                case 'TRAFFIC_JAM': return 8;
                case 'ROAD_CLOSURE': return Infinity;
                case TILE_TYPES.LARGE_ROAD: return 1;
                case TILE_TYPES.DIAGONAL: return 2;
                case TILE_TYPES.SMALL_ROAD: return 3;
                default: return 1;
            }
        }

        function reconstructPath(cameFrom, current) {
            const totalPath = [current];
            let currentKey = `${current.x},${current.y}`;
            while (cameFrom[currentKey]) {
                current = cameFrom[currentKey];
                currentKey = `${current.x},${current.y}`;
                totalPath.unshift(current);
            }
            return totalPath;
        }

        function calculatePathCost(path, dynamicGrid) {
            let totalCost = 0;
            for (let pos of path) {
                totalCost += getCost(dynamicGrid[pos.y][pos.x]);
            }
            return totalCost;
        }

        // --- Event Handlers ---
        function handleGenerate() {
            if (isAnimating) {
                isAnimating = false;
            }
            
            currentHour = parseInt(timeSelector.value);
            const timeText = timeSelector.options[timeSelector.selectedIndex].text;
            statusEl.textContent = `Calculating optimal route for ${timeText}...`;
            generateBtn.disabled = true;

            setTimeout(() => {
                try {
                    generateMap();
                    const dynamicGrid = addTraffic(grid, currentHour);
                    const vehicle = VEHICLE_CONFIG[currentDifficulty];

                    const path = solvePath(dynamicGrid, startPos, endPos, vehicle);
                    
                    if (path.length > 0) {
                        const totalCost = calculatePathCost(path, dynamicGrid);
                        statusEl.textContent = `Route found! Distance: ${path.length} blocks, Time cost: ${totalCost.toFixed(1)}`;
                        animateVehicle(dynamicGrid, path);
                    } else {
                        drawMap(dynamicGrid);
                        statusEl.textContent = 'No route available! Try a different vehicle or time.';
                    }
                } catch (error) {
                    console.error('Error generating route:', error);
                    statusEl.textContent = 'Error calculating route. Please try again.';
                }
                generateBtn.disabled = false;
            }, 50);
        }

        function handleDifficultyChange(e) {
            if (e.target.tagName !== 'BUTTON' || !e.target.dataset.difficulty) return;
            
            const newDifficulty = e.target.dataset.difficulty;
            currentDifficulty = newDifficulty;
            
            Array.from(difficultyButtons.children).forEach(btn => {
                btn.classList.remove('active', 'bg-blue-600', 'bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-800');
            });
            
            e.target.classList.remove('bg-gray-200', 'text-gray-800');
            e.target.classList.add('active', 'bg-blue-600', 'text-white');
            
            statusEl.textContent = `Selected: ${VEHICLE_CONFIG[currentDifficulty].name}. Click "Find Route in City" to see the optimal path.`;
            
            if (grid.length > 0 && !isAnimating) {
                const dynamicGrid = addTraffic(grid, currentHour);
                drawMap(dynamicGrid);
            }
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerSize = Math.min(container.clientWidth, container.clientHeight, 800);
            
            canvas.width = containerSize;
            canvas.height = containerSize;
            tileSize = containerSize / MAP_DIMENSIONS.width;
            
            if (grid.length > 0 && !isAnimating) {
                const dynamicGrid = addTraffic(grid);
                drawMap(dynamicGrid);
            }
        }

        function init() {
            try {
                resizeCanvas();
                
                Array.from(difficultyButtons.children).forEach(btn => {
                    btn.classList.remove('active', 'bg-blue-600', 'bg-blue-500', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                });
                
                const activeBtn = difficultyButtons.querySelector(`[data-difficulty="${currentDifficulty}"]`);
                if (activeBtn) {
                    activeBtn.classList.remove('bg-gray-200', 'text-gray-800');
                    activeBtn.classList.add('active', 'bg-blue-600', 'text-white');
                }
                
                window.addEventListener('resize', resizeCanvas);
                generateBtn.addEventListener('click', handleGenerate);
                generatePaperDatasetBtn.addEventListener('click', generatePaperCompatibleDataset);
                downloadDataBtn.addEventListener('click', downloadPaperDataset);
                difficultyButtons.addEventListener('click', handleDifficultyChange);
                timeSelector.addEventListener('change', () => {
                    currentHour = parseInt(timeSelector.value);
                    if (grid.length > 0 && !isAnimating) {
                        const dynamicGrid = addTraffic(grid, currentHour);
                        drawMap(dynamicGrid);
                    }
                });
                
                statusEl.textContent = `üß† Ready for HRM Paper Dataset! Generate 960 train + 400 test examples with systematic vehicle variants.`;
                
            } catch (error) {
                console.error('Initialization error:', error);
                statusEl.textContent = 'Error initializing game. Please refresh the page.';
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>